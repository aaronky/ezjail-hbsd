#!/bin/sh

# ugly: this variable is set during port install time
ezjail_prefix=EZJAIL_PREFIX
ezjail_etc=${ezjail_prefix}/etc
ezjail_share=${ezjail_prefix}/share/ezjail
ezjail_examples=${ezjail_prefix}/share/examples/ezjail
ezjail_jailcfgs=${ezjail_etc}/ezjail

# read user config
[ -f ${ezjail_etc}/ezjail.conf ] && . ${ezjail_etc}/ezjail.conf

# set defaults
ezjail_jaildir=${ezjail_jaildir:-"/usr/jails"}
ezjail_jailtemplate=${ezjail_jailtemplate:-"${ezjail_jaildir}/newjail"}
ezjail_jailbase=${ezjail_jailbase:-"${ezjail_jaildir}/basejail"}
ezjail_jailfull=${ezjail_jailfull:-"${ezjail_jaildir}/fulljail"}
ezjail_jailtemp=${ezjail_jailtemp:-"${ezjail_jaildir}/ezjailtemp"}
ezjail_flavours=${ezjail_flavours:-"${ezjail_jaildir}/flavours"}
ezjail_portscvsroot=${ezjail_portscvsroot:-":pserver:anoncvs@anoncvs.at.FreeBSD.org:/home/ncvs"}
ezjail_sourcetree=${ezjail_sourcetree:-"/usr/src"}
ezjail_uglyperlhack=${ezjail_uglyperlhack:-"YES"}

ezjail_mount_enable=${ezjail_mount_enable:-"YES"}
ezjail_devfs_enable=${ezjail_devfs_enable:-"YES"}
ezjail_devfs_ruleset=${ezjail_devfs_ruleset:-"devfsrules_jail"}
ezjail_procfs_enable=${ezjail_procfs_enable:-"YES"}
ezjail_fdescfs_enable=${ezjail_fdescfs_enable:-"YES"}

ezjail_dirlist="bin boot lib libexec rescue sbin usr/bin usr/games usr/include usr/lib usr/libdata usr/libexec usr/sbin usr/src usr/share"

################################
# End of variable initialization
#

# define our bail out shortcut
exerr () { echo -e "$*" >&2 ; exit 1; }

# define detach strategy for image jails
detach_images () {
  # unmount and detach memory disc
  if [ "${ezjail_imagedevice}" ]; then
    umount ${ezjail_rootdir} > /dev/null
    case ${ezjail_imagetype} in
      bde) gbde detach /dev/${ezjail_imagedevice} > /dev/null ;;
      eli) ;;
    esac
    mdconfig -d -u ${ezjail_imagedevice} > /dev/null
    [ "$1" = "success" ] || rm -f ${ezjail_image}
  fi
}

# fetch everything we need to know about an ezjail from config
fetchjailinfo () {
  ezjail_name=$1

  # Clean variables, prevent polution
  unset ezjail_config ezjail_running ezjail_hostname ezjail_rootdir ezjail_image ezjail_imagetype ezjail_ip ezjail_id

  ezjail_safename=`echo -n "${ezjail_name}" | tr -c [:alnum:] _`

  [ -e ${ezjail_jailcfgs}/${ezjail_safename}       ] && ezjail_config=${ezjail_jailcfgs}/${ezjail_safename}
  [ -e ${ezjail_jailcfgs}/${ezjail_safename}.norun ] && ezjail_config=${ezjail_jailcfgs}/${ezjail_safename}.norun
  [ "${ezjail_config}" ] || return 0

  . ${ezjail_config}
  eval ezjail_hostname=\"\$jail_${ezjail_safename}_hostname\"
  eval ezjail_rootdir=\"\$jail_${ezjail_safename}_rootdir\"
  eval ezjail_image=\"\$jail_${ezjail_safename}_image\"
  eval ezjail_imagetype=\"\$jail_${ezjail_safename}_imagetype\"
  eval ezjail_ip=\"\$jail_${ezjail_safename}_ip\"

  ezjail_softlink=${ezjail_jaildir}/`basename -- ${ezjail_rootdir}`
  ezjail_id=`jls | grep " ${ezjail_hostname} " | head -n 1 | awk {'print $1'}`
}

# fill the base jail - this function is used by install and update
ezjail_splitworld() {
  # Fill basejail from installed world
  cd ${ezjail_jailfull} || exerr "Cant access temporary Jail directory."

  # This mkdir is important, since cpio will create intermediate
  # directories with permission 0700 which is bad
  mkdir -p ${ezjail_jailbase}/usr
  for dir in ${ezjail_dirlist}; do
    find ${dir} | cpio -d -p -v ${ezjail_jailbase} || exerr "Installation of ${dir} failed."
    chflags -R noschg ${dir}; rm -r ${dir}; ln -s /basejail/${dir} ${dir}
  done
  mkdir basejail

  # Try to remove the old template jail
  [ -d ${ezjail_jailtemplate} ] && chflags -R noschg ${ezjail_jailtemplate} && rm -rf ${ezjail_jailtemplate}
  mv ${ezjail_jailfull} ${ezjail_jailtemplate}

  # If the default flavour example has not yet been copied, do it now
  [ -d ${ezjail_flavours}/default ] || mkdir -p ${ezjail_flavours} && cp -p -R ${ezjail_examples}/default ${ezjail_flavours}

  # no /usr/ports? link to /basejail/usr/ports
  [ -e ${ezjail_jailtemplate}/usr/ports ] || ln -s /basejail/usr/ports ${ezjail_jailtemplate}/usr/ports

  # A ports collection inside jails is hardly useful w/o an appropriate
  # /etc/make.conf.
  if [ -f ${ezjail_examples}/default/etc/make.conf -a ! -f ${ezjail_jailtemplate}/etc/make.conf ]; then
    cp -p ${ezjail_examples}/default/etc/make.conf ${ezjail_jailtemplate}/etc/
    echo "Note: a non-standard /etc/make.conf was copied to the template jail in order to get the ports collection running inside jails."
  fi

  # The ugly perl hack[tm]. Note: we wont do such things for any given
  # port :(
  [ "${ezjail_uglyperlhack}" = "YES" -a ! -L ${ezjail_jailbase}/usr/bin/perl ] && ln -s /usr/local/bin/perl ${ezjail_jailbase}/usr/bin/perl
}

# The user may want to have a ports tree in basejail
ezjail_updateports () {
  # if /usr/ports/CVS exists, assume cvs up is safe
  # this is legacy
  if [ -f ${ezjail_jailbase}/usr/ports/CVS/Root ]; then
    echo -n "Updating ports from "; cat ${ezjail_jailbase}/usr/ports/CVS/Root
    echo "Warning: Upgrading legacy ports copy. Consider removing ${ezjail_jailbase}/usr/ports and use the new portsnap strategy instead."
    echo "Gathering local information may take a while."
    cd ${ezjail_jailbase}/usr/ports/ && cvs -d ${ezjail_portscvsroot} up -Pd
  else
    portsnap fetch
    [ -d ${ezjail_jailbase}/usr/ports ] && ezjail_portsnapaction=update
    portsnap -p ${ezjail_jailbase}/usr/ports ${ezjail_portsnapaction:-"extract"}
  fi
  [ $? = 0 ] || exerr "Updating ports failed."
}

#############################
# End of function definitions
#

# check for command
[ $# -gt 0 ] || exerr "Usage: `basename -- $0` [config|create|delete|install|list|update] {params}"

case "$1" in
######################## ezjail-admin CREATE ########################
create)
  # Clean variables, prevent polution
  unset ezjail_rootdir ezjail_flavour ezjail_softlink ezjail_image ezjail_imagetype ezjail_imageparams ezjail_imagesize ezjail_device ezjail_config
  ezjail_fillme="YES"

  shift; while getopts :f:r:s:xic:C: arg; do case ${arg} in
    x) ezjail_fillme="NO";;
    r) ezjail_rootdir="${OPTARG}";;
    f) ezjail_flavour="${OPTARG}";;
    c) ezjail_imagetype="${OPTARG}";;
    C) ezjail_imageparams="${OPTARG}";;
    i) ezjail_imagetype=${ezjail_imagetype:-"simple"};;
    s) ezjail_imagesize="${OPTARG}";;
    ?) exerr "Usage: `basename -- $0` create [-xi] [-f flavour] [-r jailroot] [-s size] [-c bde|eli] [-C args] jailname jailip";;
  esac; done; shift $(( ${OPTIND} - 1 ))

  ezjail_name=$1; ezjail_ip=$2   

  # we need at least a name and an ip for new jail
  [ "${ezjail_name}" -a "${ezjail_ip}" -a $# -eq 2 ] || exerr "Usage: `basename -- $0` create [-xi] [-f flavour] [-r jailroot] [-s size] [-c bde|eli] [-C args] jailname jailip"

  # check for sanity of settings concerning the image feature
  [ "${ezjail_imagetype}" -a "${ezjail_fillme}" = "YES" -a ! "${ezjail_imagesize}" ] && exerr "Image jails need an image size."

  # check for a sane image type
  case ${ezjail_imagetype} in ""|simple|bde|eli) ;; *) exerr "Usage: `basename -- $0` create [-xi] [-f flavour] [-r jailroot] [-s size] [-c bde|eli] [-C args] jailname jailip";; esac

  # check for a sane image size and split it up in blocks
  if [ "${ezjail_imagesize}" ]; then
    _val=`echo "${ezjail_imagesize}"|tr A-Z a-z|sed -Ees:g:km:g -es:m:kk:g -es:k:*2b:g -es:b:*128w:g -es:w:*4\ :g -e"s:(^|[^0-9])0x:\1\0X:g" -ey:x:*:`
    _val=`echo $(( ${_val} ))`
    [ $? -eq 0 ] || exerr "Error: The image size you specified is somehow incomprehensible."
    ezjail_imageblockcount=$(( ${_val} / 1048576 ))
    ezjail_imagerestbyte=$(( ${_val} % 1048576 ))
  fi

  # check, whether ezjail-update has been called. existence of
  # ezjail_jailbase is our indicator
  [ -d ${ezjail_jailbase} ] || exerr "Error: base jail does not exist. Please run 'ezjail-admin update' first."

  # relative paths don't make sense in rc.scripts
  [ "${ezjail_jaildir%%[!/]*}" ] || exerr "Error: Need an absolute path in ezjail_jaildir, it currently is set to: ${ezjail_jaildir}."

  # jail names must not irritate file systems, excluding dots from this list
  # was done intentionally to permit foo.com style directory names, however,
  # the jail name will be foo_com in most scripts

  ezjail_hostname=`echo -n ${ezjail_name} | tr /~ __`
  ezjail_safename=`echo -n "${ezjail_name}" | tr -c [:alnum:] _`
  ezjail_rootdir=${ezjail_rootdir:-"${ezjail_jaildir}/${ezjail_hostname}"}
  ezjail_config=${ezjail_jailcfgs}/${ezjail_safename}

  # This scenario really will only lead to real troubles in the 'fulljail'
  # case, but I should still explain this to the user and not claim that
  # "an ezjail would already exist"
  case ${ezjail_hostname} in basejail|newjail|fulljail|flavous|ezjailtemp) exerr "Error: ezjail needs the ${ezjail_hostname} directory for its own administrative purposes. Please rename the ezjail.";; esac

  # jail names may lead to identical configs, eg. foo.bar.com == foo-bar.com
  # so check, whether we might be running into problems
  [ -e ${ezjail_config} ] && exerr "Error: an ezjail config already exists at ${ezjail_config}. Please rename the ezjail."

  # if jail root specified on command line is not absolute, make it absolute
  # inside our jail directory
  [ "${ezjail_rootdir%%[!/]*}" ] || ezjail_rootdir=${ezjail_jaildir}/${ezjail_rootdir}

  # if a directory at the specified jail root already exists, refuse to
  # install
  [ -e ${ezjail_rootdir} -a "${ezjail_fillme}" = "YES" ] && exerr "Error: the specified jail root ${ezjail_rootdir} alread exists."

  # if jail root specified on command line does not lie within our jail
  # directory, we need to create a softlink
  if [ "${ezjail_rootdir##${ezjail_jaildir}}" = "${ezjail_rootdir}" ]; then
    ezjail_softlink=${ezjail_jaildir}/`basename -- ${ezjail_rootdir}`
    [ -e ${ezjail_softlink} -a "${ezjail_fillme}" = "YES" ] && exerr "Error: an ezjail already exists at ${ezjail_softlink}."
  fi

  # do some sanity checks on the selected flavour (if any)
  [ "${ezjail_flavour}" -a ! -d ${ezjail_flavours}/${ezjail_flavour} ] && exerr "Error: Flavour config directory ${ezjail_flavours}/${ezjail_flavour} not found."

  #
  # All sanity checks that may lead to errors are hopefully passed here
  #

  if [ "${ezjail_imagetype}" ]; then
    # Strip trailing slashes from jail root, those would confuse image path
    ezjail_image=${ezjail_rootdir%/}; while [ "${ezjail_image}" -a -z "${ezjail_image%%*/}" ]; do ezjail_image=${ezjail_image%/}; done
    [ -z "${ezjail_image}" ] && exerr "Error: Could not determine image file name, something is wrong with the jail root: ${ezjail_rootdir}."

    # Location of our image file
    ezjail_image=${ezjail_image}.img

    # If NOT exist, create image
    if [ "${ezjail_fillme}" = "YES" ]; then
      [ -e "${ezjail_image}" ] && exerr "Error: a file exists at the location ${ezjail_image}, preventing our own image file to be created."

      # Now create jail disc image
      touch "${ezjail_image}"
      dd if=/dev/random of="${ezjail_image}" bs=1m count=${ezjail_imageblockcount} || exerr "Error: Could not (or not fully) create the image file. You might want to check (and possibly remove) the file ${ezjail_image}. The image size provided was ${ezjail_imagesize}."
      ( dd if=/dev/random bs=${ezjail_imagerestbytes} count=1 >> "${ezjail_image}" ) || exerr "Error: Could not (or not fully) create the image file. You might want to check (and possibly remove) the file ${ezjail_image}. The image size provided was ${ezjail_imagesize}."

      # And attach device
      ezjail_imagedevice=`mdconfig -a -t vnode -f ${ezjail_image}`
      [ $? = 0 ] || detach_images || exerr "Error: Could not attach image device. (Command failed was 'mdconfig -a -t vnode -f ${ezjail_image}')"

      case "${ezjail_imagetype}" in
        bde)
          # Initialise crypto image
          echo "Initialising crypto device. Enter a new passphrase twice..."
          gbde init /dev/${ezjail_imagedevice} || detach_images || exerr "Error: Could not initialise crypto image."

          echo "Attaching crypto device. Enter the passphrase..."
          gbde attach /dev/${ezjail_imagedevice} || detach_images || exerr "Error: Could not attach crypto image."
          ezjail_device=${ezjail_imagedevice}.bde
        ;;
       eli)
        ;;
       simple)
        ezjail_device=${ezjail_imagedevice}
        ;;
      esac

      # Format memory image
      newfs /dev/${ezjail_device} || detach_images || exerr "Error: Could not newfs /dev/${ezjail_device}."
      # Create mount point and mount
      mkdir -p ${ezjail_rootdir} || detach_images || exerr "Error: Could not create jail root mount point ${ezjail_rootdir}."
      mount /dev/${ezjail_device} ${ezjail_rootdir} || detach_images || exerr "Error: Could not mount /dev/${ezjail_device} to ${ezjail_root}."
    else
      [ -e ${ezjail_rootdir} -a ! -d ${ezjail_rootdir} ] && exerr "Error: Could not create mount point for your jail image. A file exists at its location. (For existing image jails, call this tool without the .img suffix when specifying jail root.)"
      [ -d ${ezjail_rootdir} ] || mkdir -p ${ezjail_rootdir}
    fi
  fi

  # now take a copy of our template jail
  if [ "${ezjail_fillme}" = "YES" ]; then
    mkdir -p ${ezjail_rootdir} && cd ${ezjail_jailtemplate} && find * | cpio -p -v ${ezjail_rootdir} > /dev/null
    [ $? = 0 ] || detach_images || exerr "Error: Could not copy template jail."
  fi

  # if a soft link is necessary, create it now
  [ "${ezjail_softlink}" ] && ln -s ${ezjail_rootdir} ${ezjail_softlink}

  # if the automount feature is not disabled, this fstab entry for new jail
  # will be obeyed
  echo -n > /etc/fstab.${ezjail_safename}
  [ "${ezjail_imagetype}" ] && \
  echo ${ezjail_rootdir}.device ${ezjail_rootdir} ufs rw 0 0 >> /etc/fstab.${ezjail_safename}
  echo ${ezjail_jailbase} ${ezjail_rootdir}/basejail nullfs ro 0 0 >> /etc/fstab.${ezjail_safename}

  # now, where everything seems to have gone right, create control file in  
  # ezjails config dir
  mkdir -p ${ezjail_jailcfgs}
  echo "# To specify the start up order of your ezjails, use these lines to" > ${ezjail_config}
  echo "# create a Jail dependency tree. See rcorder(8) for more details." >> ${ezjail_config}
  echo -e "#\n# PROVIDE: \n# REQUIRE: \n# BEFORE: \n#\n" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_hostname=\"${ezjail_hostname}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_ip=\"${ezjail_ip}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_rootdir=\"${ezjail_rootdir}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_exec=\"/bin/sh /etc/rc\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_mount_enable=\"${ezjail_mount_enable}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_devfs_enable=\"${ezjail_devfs_enable}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_devfs_ruleset=\"devfsrules_jail\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_procfs_enable=\"${ezjail_procfs_enable}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_fdescfs_enable=\"${ezjail_fdescfs_enable}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_image=\"${ezjail_image}\" >> ${ezjail_config}
  echo export jail_${ezjail_safename}_imagetype=\"${ezjail_imagetype}\" >> ${ezjail_config}

  # Final steps for flavour installation
  if [ "${ezjail_fillme}" = "YES" -a "${ezjail_flavour}" ]; then
    # install files and config to new jail
    cd ${ezjail_flavours}/${ezjail_flavour} && find * | cpio -p -u -v ${ezjail_rootdir} > /dev/null
    [ $? = 0 ] || echo "Warning: Could not fully install flavour."

    # If a config is found, make it auto run on jails startup
    if [ -f ${ezjail_rootdir}/ezjail.flavour ]; then
      ln -s /ezjail.flavour ${ezjail_rootdir}/etc/rc.d/ezjail-config.sh
      chmod 0700 ${ezjail_rootdir}/ezjail.flavour
      echo "Note: Shell scripts installed, flavourizing on jails first startup."
    fi
  fi

  # Detach (crypto and) memory discs
  detach_images success

  #
  # For user convenience some scenarios commonly causing headaches are checked
  #

  # check, whether IP is configured on a local interface, warn if it isnt
  ping -c 1 -m 1 -t 1 -q ${ezjail_ip} > /dev/null
  [ $? = 0 ] || echo "Warning: IP ${ezjail_ip} not configured on a local interface."

  # check, whether some host system services do listen on the Jails IP
  TIFS=${IFS}; IFS=_
  ezjail_listener=`sockstat -4 -l | grep ${ezjail_ip}:[[:digit:]]`
  [ $? = 0 ] && echo -e "Warning: Some services already seem to be listening on IP ${ezjail_ip}\n  This may cause some confusion, here they are:\n${ezjail_listener}"

  ezjail_listener=`sockstat -4 -l | grep \*:[[:digit:]]`
  [ $? = 0 ] && echo -e "Warning: Some services already seem to be listening on all IP, (including ${ezjail_ip})\n  This may cause some confusion, here they are:\n${ezjail_listener}"
  IFS=${TIFS}
  
  ;;
######################## ezjail-admin DELETE ########################
delete)
  # Clean variables, prevent polution
  unset ezjail_wipeme

  shift; while getopts :w arg; do case ${arg} in
    w) ezjail_wipeme="YES";;
    ?) exerr "Usage: `basename -- $0` delete [-w] jailname";;
  esac; done; shift $(( $OPTIND - 1 ))

  # we need name of jail to vanish
  [ $# -eq 1 ] || exerr "Usage: `basename -- $0` delete [-w] jailname"

  # Get all info we have on that jail
  fetchjailinfo $1

  # check for existence of jail in our records
  [ "${ezjail_config}" ] || exerr "Error: Nothing known about jail ${ezjail_name}."

  # if jail is still running, refuse to go any further
  [ "${ezjail_id}" ] && exerr "Error: Jail appears to be still running, stop it first."

  # now we know everything we need to let the jail be gone remove entry
  # from ezjail resource structure, delete fstab.JAILNAME
  rm -f ${ezjail_config} /etc/fstab.${ezjail_safename}

  # if there is a soft link pointing to the jail root, remove it
  [ -L ${ezjail_softlink} ] && rm ${ezjail_softlink}

  # if wiping the jail was requested, remove it
  if [ "${ezjail_wipeme}" ]; then
    [ "${ezjail_image}" ] && rm -f ${ezjail_image} ${ezjail_image%.img}.device
    rm -rf ${ezjail_rootdir}
  fi

  ;;
######################## ezjail-admin LIST ########################
list)
  [ $# -eq 1 ] || exerr "Usage: `basename -- $0` list"

  ezjail_list=`find -X ${ezjail_prefix}/etc/ezjail/ 2> /dev/null | xargs rcorder | xargs basename -a`

  printf "%-3s %-5s %-15s %-28s %s\\n" STA JID IP Hostname "Root Directory"
  echo   "--- ----- --------------- ---------------------------- -----------------------------"
  for ezjail in ${ezjail_list}; do
    fetchjailinfo ${ezjail%.norun}
    case ${ezjail_imagetype} in simple) ezjail_state="I";; bde) ezjail_state="B";; eli) ezjail_state="E";; *) ezjail_state="D";; esac
    [ "${ezjail_id}" ] && ezjail_state=${ezjail_state}R || ezjail_state=${ezjail_state}S
    [ "${ezjail_safename}" != "${ezjail}" ] && ezjail_state=${ezjail_state}N

    printf "%-3s %-5s %-15s %-28s %s\\n" "${ezjail_state}" "${ezjail_id:-N/A}" "${ezjail_ip}" "${ezjail_hostname}" "${ezjail_rootdir}"
  done

  ;;
######################## ezjail-admin UPDATE ########################
setup|update)
  # Clean variables, prevent polution
  unset ezjail_provideports
  ezjail_installaction="world"

  shift; while getopts :ipPs: arg; do case ${arg} in
    i) ezjail_installaction="installworld";;
    s) ezjail_sourcetree="${OPTARG}";;
    p) ezjail_provideports="YES";;
    P) ezjail_provideports="YES"; ezjail_installaction="none";;
    ?) exerr "Usage: `basename -- $0` update [-s sourcetree] [-i] [-pP]";;
  esac; done; shift $(( ${OPTIND} - 1 ))

  [ $# -eq 0 ] || exerr "Usage: `basename -- $0` update [-s sourcetree] [-i] [-pP]"

  if [ "${ezjail_installaction}" = "none" ]; then
    # check, whether ezjail-update has been called. existence of
    # ezjail_jailbase is our indicator
    [ -d ${ezjail_jailbase} ] || exerr "Error: base jail does not exist. You cannot fill base jails ports tree before creating it. Please run 'ezjail-admin update' first."
  else
    # Bump the user for some of the most common errors
    [ -d ${ezjail_sourcetree} ] || exerr "Cannot find your copy of the FreeBSD source tree in ${ezjail_sourcetree}."
    [ -e ${ezjail_sourcetree}/Makefile ] || exerr "Your source tree in ${ezjail_sourcetree} seems to be incomplete (Makefile missing)."

    # Normally fulljail should be renamed by past ezjail-admin commands.
    # However those may have failed
    [ -d "${ezjail_jailfull}" ] && chflags -R noschg ${ezjail_jailfull} && rm -rf ${ezjail_jailfull}
    mkdir -p ${ezjail_jailfull} || exerr "Cannot create temporary Jail directory."

    # make and setup our world, then split basejail and newjail
    cd ${ezjail_sourcetree} && make ${ezjail_installaction} DESTDIR=${ezjail_jailfull} || exerr "make ${ezjail_installaction} failed."
    cd ${ezjail_sourcetree}/etc && make distribution DESTDIR=${ezjail_jailfull} || exerr "make distribution failed."
    ezjail_splitworld

  fi # installaction="none"

  # Provide a copy of ports tree in basejail
  [ "${ezjail_provideports}" = "YES" ] && ezjail_updateports

  ;;
######################## ezjail-admin INSTALL ########################
install)
  # Clean variables, prevent polution
  unset ezjail_release ezjail_ftphost ezjail_installmanpages ezjail_installports ezjail_installsources ezjail_dir ezjail_reldir

  shift; while getopts :mpsh:r: arg; do case ${arg} in
    m) ezjail_installmanpages=" manpages";;
    s) ezjail_installsources=" src";;
    p) ezjail_installports="YES";;
    h) ezjail_ftphost="${OPTARG}";;
    r) ezjail_release="${OPTARG}";;
    ?) exerr "Usage: `basename -- $0` install [-mps] [-h host] [-r release]";;
  esac; done; shift $(( ${OPTIND} - 1 ))

  [ $# -eq 0 ] || exerr "Usage: `basename -- $0` install [-mps] [-h host] [-r release]"

  ezjail_installarch=`uname -p`
  ezjail_ftphost=${ezjail_ftphost:-"ftp.freebsd.org"}
  ezjail_ftphost=${ezjail_ftphost#ftp://}
  ezjail_dir=${ezjail_ftphost#file://}
  [ "${ezjail_dir%%[!/]*}" ] || ezjail_reldir=${PWD}

  # ftp servers normally wont provide non-RELEASE-builds
  if [ -z "${ezjail_release}" ]; then
    ezjail_release=`uname -r`
    if [ "${ezjail_release%-RELEASE}" != "${ezjail_release}" -a "${ezjail_dir}" = "${ezjail_ftphost}" ]; then
      echo "Your system is ${ezjail_release}. Normally FTP-servers don't provide non-RELEASE-builds."
      echo -n "Release [ ${ezjail_release} ]: "
      read ezjail_releasetmp
      [ "${ezjail_releasetmp}" ] && ezjail_release=${ezjail_releasetmp}
    fi
  fi

  # Normally fulljail should be renamed by past ezjail-admin commands.
  # However those may have failed
  [ -d "${ezjail_jailfull}" ] && chflags -R noschg ${ezjail_jailfull} && rm -rf ${ezjail_jailfull}
  mkdir -p ${ezjail_jailfull} || exerr "Cannot create temporary Jail directory."
  DESTDIR=${ezjail_jailfull}

  rm -rf ${ezjail_jailtemp}
  for pkg in base ${ezjail_installmanpages} ${ezjail_installsources}; do

    # The first case means, that a remote host has been specified.
    if [ "${ezjail_dir}" = "${ezjail_ftphost}" ]; then
      # Create and try to access temp dir
      mkdir -p ${ezjail_jailtemp} || exerr "Could not create temporary base jail directory ${ezjail_jailtemp}."
      cd ${ezjail_jailtemp} || exerr "Could not cd to ${ezjail_jailtemp}."

      # Try all paths as stolen from sysinstall, break on success.
      for ezjail_path in pub/FreeBSD/releases pub/FreeBSD/snapshot pub/FreeBSD releases snapshots NO; do
        [ "${ezjail_path}" = "NO" ] && exerr "Could not fetch ${pkg} from ${ezjail_ftphost}."
        ftp "${ezjail_ftphost}:${ezjail_path}/${ezjail_installarch}/${ezjail_release}/${pkg}/*" && break
      done

      # These actions are really ugly: sources want $1 to contain the set
      # of sources to install, base asks the user if he is sure, hence the
      # yes and the set -- all
      set -- all
      [ -f install.sh ] && yes | . install.sh
      [ $? = 0 ] || exerr "Package install script for ${pkg} failed."

      rm -rf ${ezjail_jailtemp}
    else
      cd ${basejail_reldir}/${basejail_dir}/${pkg} || exerr "Could not cd to ${basejail_dir}."
      set -- all
      [ -f install.sh ] && yes | . install.sh
      [ $? = 0 ] || exerr "Package install script for ${pkg} failed."
    fi
  done

  # Split basejail and newjail
  ezjail_splitworld

  # Fill ports, if requested
  [ "${ezjail_installports}" = "YES" ] && ezjail_updateports

  ;;
######################## ezjail-admin CONFIG ########################
config)
  # Clean variables, prevent polution
  unset ezjail_setrunnable

  shift; while getopts :r: arg; do case ${arg} in
    r) ezjail_setrunnable=${OPTARG};;
    ?) exerr "Usage: `basename -- $0` config [-r run|norun] jailname";;
  esac; done; shift $(( ${OPTIND} - 1 ))

  [ $# -eq 1 ] || exerr "Usage: `basename -- $0` config [-r run|norun] jailname"

  # Jail name mandatory
  fetchjailinfo $1

  # check for existence of jail in our records
  [ "${ezjail_config}" ] || exerr "Error: Nothing known about jail ${ezjail_name}."

  # Nothing to be configured?
  [ "${ezjail_setrunnable}" ] || echo "Warning: No config option specified."

  case ${ezjail_setrunnable} in
    run)
    [ "${ezjail_config}" = "${ezjail_config%.norun}" ] || mv ${ezjail_config} ${ezjail_config%.norun}
    ;;
    norun)
    [ "${ezjail_config}" = "${ezjail_config%.norun}" ] && mv ${ezjail_config} ${ezjail_config}.norun
    ;;
  esac

  ;;
*)
  exerr "Usage: `basename -- $0` [config|create|delete|install|list|update] {params}"
  ;;
esac
